package util;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

public final class JDBCUtil {
    private static String connect;
    private static String driverClassName;
    private static String URL;
    private static String username;
    private static String password;
    private static boolean autoCommit;
    private static Connection conn;

    static {
        config();
    }

    private static void config() {
        connect = "h2";
        driverClassName = "org.h2.Driver";
        URL = "jdbc:h2:file:./src/main/resources/db/db";
        username = "db";
        password = "db";
        autoCommit = false;
    }

    private static void load() {
        try {
            Class.forName(driverClassName);
        } catch (ClassNotFoundException e) {
            System.out.println("驱动类 " + driverClassName + " 加载失败");
        }
    }

    private static boolean invalid() {
        if (conn != null) {
            try {
                if (conn.isClosed() || !conn.isValid(3)) {
                    return true;
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return false;
        } else {
            return true;
        }
    }

    public static Connection connect() {
        if (invalid()) {
            load();
            try {
                conn = DriverManager.getConnection(URL, username, password);
            } catch (SQLException e) {
                System.out.println("建立" + connect + "数据库连接失败 , " + e.getMessage());
            }
        }
        return conn;
    }

    public static void transaction() {
        try {
            conn.setAutoCommit(autoCommit);
        } catch (SQLException e) {
            System.out.println("事务提交: " + (autoCommit ? "自动提交" : "手动提交") + " 时失败: " + e.getMessage());
        }
    }

    public static Statement statement() {
        Statement st = null;
        connect();
        transaction();
        try {
            st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
        } catch (SQLException e) {
            System.out.println("创建 Statement 对象失败: " + e.getMessage());
        }
        return st;
    }

    private static PreparedStatement prepare(String SQL, boolean autoGeneratedKeys) {
        PreparedStatement ps = null;
        connect();
        transaction();
        try {
            if (autoGeneratedKeys) {
                ps = conn.prepareStatement(SQL, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE, ResultSet.HOLD_CURSORS_OVER_COMMIT);
            } else {
                ps = conn.prepareStatement(SQL, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
            }
        } catch (SQLException e) {
            System.out.println("创建 PreparedStatement 对象失败: " + e.getMessage());
        }
        return ps;
    }

    public static ResultSet query(String SQL, List<Object> params) {
        if (SQL == null || SQL.trim().isEmpty() || !SQL.trim().toLowerCase().startsWith("select")) {
            throw new RuntimeException("SQL语句为空或不是查询语句");
        }
        ResultSet rs = null;
        if (params.size() > 0) {
            PreparedStatement ps = prepare(SQL, false);
            try {
                for (int i = 0; i < params.size(); i++) {
                    ps.setObject(i + 1, params.get(i));
                }
                rs = ps.executeQuery();
            } catch (SQLException e) {
                System.out.println("执行SQL失败: " + e.getMessage());
            }
        }
        else {
            // 没有传入任何参数
            Statement st = statement();
            try {
                rs = st.executeQuery(SQL);
            } catch (SQLException e) {
                System.out.println("执行SQL失败: " + e.getMessage());
            }
        }
        return rs;
    }

    private static Object typeof(Object o) {
        Object r = o;
        if (o instanceof java.sql.Timestamp) {
            return r;
        }
        // 将 java.util.Date 转成 java.sql.Date
        if (o instanceof java.util.Date) {
            java.util.Date d = (java.util.Date) o;
            r = new java.sql.Date(d.getTime());
            return r;
        }
        // 将 Character 或 char 变成 String
        if (o instanceof Character) {
            r = String.valueOf(o);
            return r;
        }
        return r;
    }

    /*
     * @param SQL 需要执行的 INSERT 语句
     * @param autoGeneratedKeys 指示是否需要返回由数据库产生的键
     * @param params 将要执行的SQL语句中包含的参数占位符的 参数值
     * @return 如果指定 autoGeneratedKeys 为 true 则返回由数据库产生的键； 如果指定 autoGeneratedKeys
     * 为 false 则返回受当前SQL影响的记录数目
     */
    public static int insert(String SQL, boolean autoGeneratedKeys, List<Object> params) {
        int var = -1;
        if (SQL == null || SQL.trim().isEmpty()) {
            throw new RuntimeException("没有指定SQL语句，请检查是否指定需要执行的SQL语句");
        }
        // 如果不是 insert 开头开头的语句
        if (!SQL.trim().toLowerCase().startsWith("insert")) {
            System.out.println(SQL.toLowerCase());
            throw new RuntimeException("指定的SQL语句不是插入语句");
        }
        // 获得被执行的 SQL 语句的 前缀 ( 第一个单词 )
        SQL = SQL.trim();
        SQL = SQL.toLowerCase();
        if (params.size() > 0) {
            PreparedStatement ps = prepare(SQL, autoGeneratedKeys);
            Connection c = null;
            try {
                c = ps.getConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                for (int i = 0; i < params.size(); i++) {
                    Object p = params.get(i);
                    p = typeof(p);
                    ps.setObject(i + 1, p);
                }
                int count = ps.executeUpdate();
                if (autoGeneratedKeys) { // 如果希望获得数据库产生的键
                    ResultSet rs = ps.getGeneratedKeys(); // 获得数据库产生的键集
                    if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
                        var = rs.getInt(1); // 获得值并赋值给 var 变量
                    }
                } else {
                    var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
                }
                commit(c);
            } catch (SQLException e) {
                System.out.println("数据保存失败: " + e.getMessage());
                rollback(c);
            }
        } else {
            Statement st = statement();
            Connection c = null;
            try {
                c = st.getConnection();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            try {
                int count = st.executeUpdate(SQL);
                if (autoGeneratedKeys) { // 如果希望获得数据库产生的键
                    ResultSet rs = st.getGeneratedKeys(); // 获得数据库产生的键集
                    if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
                        var = rs.getInt(1); // 获得值并赋值给 var 变量
                    }
                } else {
                    var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
                }
                commit(c);
            } catch (SQLException e) {
                System.out.println("数据保存失败: " + e.getMessage());
                rollback(c);
            }
        }
        return var;
    }

    private static void commit(Connection c) {
        if (c != null && !autoCommit) {
            try {
                c.commit();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    private static void rollback(Connection c) {
        if (c != null && !autoCommit) {
            try {
                c.rollback();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

}